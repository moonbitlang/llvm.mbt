package "Kaida-Amethyst/llvm/llvm"

import(
  "Kaida-Amethyst/llvm/unsafe"
)

// Values
fn raise_builder_error(Int) -> Int raise BuilderError

// Types and methods
pub type AddressSpace UInt
fn AddressSpace::from(UInt) -> Self
fn AddressSpace::inner(Self) -> UInt
fn AddressSpace::into(Self) -> UInt
impl Default for AddressSpace
impl Eq for AddressSpace
impl Show for AddressSpace

pub enum AggregateValueEnum {
  StructValue(StructValue)
  ArrayValue(ArrayValue)
  VectorValue(VectorValue)
  ScalableVectorValue(ScalableVectorValue)
}
fn AggregateValueEnum::as_aggregate_value_class(Self) -> &AggregateValue
fn AggregateValueEnum::init(@unsafe.LLVMValueRef) -> Self

pub struct ArrayType {
  ty : TypeRef
}
fn ArrayType::const_array(Self, Array[&BasicValue]) -> ArrayValue
fn ArrayType::const_zero(Self) -> ArrayValue
fn ArrayType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn ArrayType::get_alignment(Self) -> IntValue
fn ArrayType::get_context(Self) -> Context
fn ArrayType::get_element_type(Self) -> &BasicType
fn ArrayType::get_poison(Self) -> ArrayValue
fn ArrayType::get_undef(Self) -> ArrayValue
fn ArrayType::is_empty(Self) -> Bool
fn ArrayType::is_sized(Self) -> Bool
fn ArrayType::len(Self) -> UInt
fn ArrayType::length(Self) -> UInt
fn ArrayType::new(@unsafe.LLVMTypeRef) -> Self
impl BasicType for ArrayType
impl Type for ArrayType
impl Show for ArrayType

pub struct ArrayValue {
  value : ValueRef
}
fn ArrayValue::as_instruction(Self) -> InstructionValue?
fn ArrayValue::get_name(Self) -> String
fn ArrayValue::get_string_constant(Self) -> String?
fn ArrayValue::get_type(Self) -> ArrayType
fn ArrayValue::is_const(Self) -> Bool
fn ArrayValue::is_const_string(Self) -> Bool
fn ArrayValue::is_null(Self) -> Bool
fn ArrayValue::is_undef(Self) -> Bool
fn ArrayValue::new(@unsafe.LLVMValueRef) -> Self
fn ArrayValue::new_const_array(&Type, Array[&Value]) -> Self
fn ArrayValue::replace_all_uses_with(Self, Self) -> Unit
fn ArrayValue::set_name(Self, String) -> Unit
impl AggregateValue for ArrayValue
impl BasicValue for ArrayValue
impl Value for ArrayValue
impl Show for ArrayValue

pub(all) enum AtomicOrdering {
  NotAtomic
  Unordered
  Monotonic
  Acquire
  Release
  AcquireRelease
  SequentiallyConsistent
}
fn AtomicOrdering::from(@unsafe.LLVMAtomicOrdering) -> Self
fn AtomicOrdering::into(Self) -> @unsafe.LLVMAtomicOrdering
impl Eq for AtomicOrdering
impl Hash for AtomicOrdering
impl Show for AtomicOrdering

pub(all) enum AtomicRMWBinOp {
  Xchg
  Add
  Sub
  And
  Nand
  Or
  Xor
  Max
  Min
  UMax
  UMin
  FAdd
  FSub
  FMax
  FMin
  UIncWrap
  UDecWrap
}
fn AtomicRMWBinOp::from(@unsafe.LLVMAtomicRMWBinOp) -> Self
fn AtomicRMWBinOp::into(Self) -> @unsafe.LLVMAtomicRMWBinOp
impl Eq for AtomicRMWBinOp
impl Hash for AtomicRMWBinOp
impl Show for AtomicRMWBinOp

pub struct Attribute {
  attribute : @unsafe.LLVMAttributeRef
}
fn Attribute::as_attr_ref(Self) -> @unsafe.LLVMAttributeRef
fn Attribute::get_enum_kind_id(Self) -> UInt
fn Attribute::get_enum_kind_id_is_valid(Self) -> Bool
fn Attribute::get_enum_value(Self) -> UInt64
fn Attribute::get_last_enum_kind_id() -> UInt
fn Attribute::get_named_enum_kind_id(String) -> UInt
fn Attribute::get_string_kind_id(Self) -> String
fn Attribute::get_string_value(Self) -> String
fn Attribute::get_type_value(Self) -> &Type
fn Attribute::is_enum(Self) -> Bool
fn Attribute::is_string(Self) -> Bool
fn Attribute::is_type(Self) -> Bool
fn Attribute::new(@unsafe.LLVMAttributeRef) -> Self
impl Eq for Attribute
impl Show for Attribute

pub(all) enum AttributeLoc {
  Return
  Param(UInt)
  Function
}
fn AttributeLoc::get_index(Self) -> UInt
fn AttributeLoc::new(Int) -> Self

pub struct BasicBlock {
  bb_ref : @unsafe.LLVMBasicBlockRef
}
fn BasicBlock::as_bb_ref(Self) -> @unsafe.LLVMBasicBlockRef
fn BasicBlock::delete(Self) -> Unit raise MoonllvmError
fn BasicBlock::get_address(Self) -> PointerValue?
fn BasicBlock::get_context(Self) -> Context
fn BasicBlock::get_first_instruction(Self) -> InstructionValue?
fn BasicBlock::get_first_use(Self) -> BasicValueUse?
fn BasicBlock::get_instruction_with_name(Self, String) -> InstructionValue?
fn BasicBlock::get_last_instruction(Self) -> InstructionValue?
fn BasicBlock::get_name(Self) -> String
fn BasicBlock::get_next_basic_block(Self) -> Self?
fn BasicBlock::get_parent(Self) -> FunctionValue?
fn BasicBlock::get_previous_basic_block(Self) -> Self?
fn BasicBlock::get_terminator(Self) -> InstructionValue?
fn BasicBlock::move_after(Self, Self) -> Unit raise MoonllvmError
fn BasicBlock::move_before(Self, Self) -> Unit raise MoonllvmError
fn BasicBlock::new(@unsafe.LLVMBasicBlockRef) -> Self
fn BasicBlock::remove_from_function(Self) -> Unit raise MoonllvmError
fn BasicBlock::replace_all_uses_with(Self, Self) -> Unit
fn BasicBlock::set_name(Self, String) -> Unit
impl Eq for BasicBlock

pub(all) enum BasicTypeEnum {
  ArrayType(ArrayType)
  FloatType(FloatType)
  IntType(IntType)
  PointerType(PointerType)
  StructType(StructType)
  VectorType(VectorType)
  ScalableVectorType(ScalableVectorType)
}
fn BasicTypeEnum::as_basic_type_class(Self) -> &BasicType
fn BasicTypeEnum::init(@unsafe.LLVMTypeRef) -> Self

pub(all) enum BasicValueEnum {
  ArrayValue(ArrayValue)
  IntValue(IntValue)
  FloatValue(FloatValue)
  PointerValue(PointerValue)
  StructValue(StructValue)
  VectorValue(VectorValue)
  ScalableVectorValue(ScalableVectorValue)
}
fn BasicValueEnum::as_basic_value_class(Self) -> &BasicValue
fn BasicValueEnum::init(@unsafe.LLVMValueRef) -> Self

pub struct BasicValueUse {
  use_ref : @unsafe.LLVMUseRef
}
fn BasicValueUse::as_use_ref(Self) -> @unsafe.LLVMUseRef
fn BasicValueUse::get_next_use(Self) -> Self?
fn BasicValueUse::get_used_value(Self) -> Either[BasicValueEnum, BasicBlock]
fn BasicValueUse::get_user(Self) -> ValueEnum
fn BasicValueUse::new(@unsafe.LLVMUseRef) -> Self

pub struct Builder {
  builder_ref : @unsafe.LLVMBuilderRef
  mut positioned : PositionState
}
fn Builder::build_address_space_cast(Self, PointerValue, PointerType, name~ : String = ..) -> PointerValue raise BuilderError
fn Builder::build_aggregate_return(Self, Array[&BasicValue]) -> InstructionValue raise BuilderError
fn Builder::build_alloca(Self, &BasicType, name~ : String = ..) -> PointerValue raise BuilderError
fn[T : IntMathValue] Builder::build_and(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn Builder::build_array_alloca(Self, &BasicType, &BasicValue, name~ : String = ..) -> PointerValue raise BuilderError
fn Builder::build_array_malloc(Self, &BasicType, IntValue, name~ : String = ..) -> PointerValue raise BuilderError
fn[T : BasicValue] Builder::build_binop(Self, InstructionOpcode, T, T, name~ : String = ..) -> BasicValueEnum raise BuilderError
fn Builder::build_bit_cast(Self, &BasicValue, &BasicType, name~ : String = ..) -> &BasicValue raise BuilderError
fn Builder::build_call(Self, FunctionValue, Array[&BasicValue], name~ : String = ..) -> CallSiteValue raise BuilderError
fn[T : BasicType, V : BasicValue] Builder::build_cast(Self, InstructionOpcode, V, T, name~ : String = ..) -> &BasicValue raise BuilderError
fn Builder::build_conditional_branch(Self, IntValue, BasicBlock, BasicBlock) -> InstructionValue raise BuilderError
fn Builder::build_direct_call(Self, FunctionValue, Array[&BasicValue], name~ : String = ..) -> CallSiteValue raise BuilderError
fn Builder::build_direct_call_with_operand_bundles(Self, FunctionValue, Array[&BasicValue], Array[OperandBundle], name~ : String = ..) -> CallSiteValue raise BuilderError
fn Builder::build_direct_invoke(Self, FunctionValue, Array[&BasicValue], BasicBlock, BasicBlock, name~ : String = ..) -> CallSiteValue raise BuilderError
fn Builder::build_extract_element(Self, VectorValue, IntValue, name~ : String = ..) -> &BasicValue raise BuilderError
fn[AV : AggregateValue] Builder::build_extract_value(Self, AV, UInt, name~ : String = ..) -> BasicValueEnum raise BuilderError
fn Builder::build_fence(Self, AtomicOrdering, Bool, name~ : String = ..) -> InstructionValue raise BuilderError
fn[T : FloatMathValue] Builder::build_float_add(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : FloatMathValue] Builder::build_float_compare(Self, FloatPredicate, T, T, name~ : String = ..) -> IntValue raise BuilderError
fn Builder::build_float_div(Self, FloatValue, FloatValue, name~ : String = ..) -> FloatValue raise BuilderError
fn[T : FloatMathValue] Builder::build_float_mul(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : FloatMathValue] Builder::build_float_neg(Self, T, name~ : String = ..) -> T raise BuilderError
fn[T : FloatMathValue] Builder::build_float_rem(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : FloatMathValue] Builder::build_float_sub(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn Builder::build_free(Self, PointerValue) -> InstructionValue raise BuilderError
fn[T : BasicType] Builder::build_gep(Self, T, PointerValue, Array[IntValue], name~ : String = ..) -> PointerValue raise BuilderError
fn Builder::build_global_string(Self, String, name~ : String = ..) -> GlobalValue raise BuilderError
fn Builder::build_global_string_ptr(Self, String, name~ : String = ..) -> GlobalValue raise BuilderError
fn Builder::build_in_bounds_gep(Self, &BasicType, PointerValue, Array[IntValue], name~ : String = ..) -> PointerValue raise BuilderError
fn Builder::build_indirect_branch(Self, BasicValueEnum, Array[BasicBlock]) -> InstructionValue raise BuilderError
fn Builder::build_indirect_call(Self, FunctionType, PointerValue, Array[&BasicValue], name~ : String = ..) -> CallSiteValue raise BuilderError
fn Builder::build_indirect_call_with_operand_bundles(Self, FunctionType, PointerValue, Array[&BasicValue], Array[OperandBundle], name~ : String = ..) -> CallSiteValue raise BuilderError
fn Builder::build_indirect_invoke(Self, FunctionType, PointerValue, Array[&BasicValue], BasicBlock, BasicBlock, name~ : String = ..) -> CallSiteValue raise BuilderError
fn[V : BasicValue, W : VectorBaseValue] Builder::build_insert_element(Self, W, V, IntValue, name~ : String = ..) -> W raise BuilderError
fn Builder::build_insert_value(Self, &AggregateValue, &BasicValue, UInt, name~ : String = ..) -> &AggregateValue raise BuilderError
fn[T : IntMathValue] Builder::build_int_add(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_compare(Self, IntPredicate, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_exact_signed_div(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_mul(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_neg(Self, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nsw_add(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nsw_mul(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nsw_neg(Self, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nsw_sub(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nuw_add(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nuw_mul(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nuw_neg(Self, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_nuw_sub(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_signed_div(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_signed_rem(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_sub(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_unsigned_div(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_int_unsigned_rem(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn Builder::build_invoke(Self, FunctionValue, Array[&BasicValue], BasicBlock, BasicBlock, name~ : String = ..) -> CallSiteValue raise BuilderError
fn[T : PointerMathValue] Builder::build_is_null(Self, T, name~ : String = ..) -> IntValue raise BuilderError
fn Builder::build_landing_pad(Self, &BasicType, FunctionValue, Array[&BasicValue], Bool, name~ : String = ..) -> BasicValueEnum raise BuilderError
fn[T : IntMathValue] Builder::build_left_shift(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn Builder::build_load(Self, &BasicType, PointerValue, name~ : String = ..) -> &BasicValue raise BuilderError
fn[T : BasicType] Builder::build_malloc(Self, T, name~ : String = ..) -> PointerValue raise BuilderError
fn Builder::build_memcpy(Self, PointerValue, UInt, PointerValue, UInt, IntValue) -> PointerValue raise BuilderError
fn Builder::build_memmove(Self, PointerValue, UInt, PointerValue, UInt, IntValue) -> PointerValue raise BuilderError
fn Builder::build_memset(Self, PointerValue, UInt, IntValue, IntValue) -> PointerValue raise BuilderError
fn[T : IntMathValue] Builder::build_not(Self, T, name~ : String = ..) -> T raise BuilderError
fn[T : IntMathValue] Builder::build_or(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn[T : BasicType] Builder::build_phi(Self, T, name~ : String = ..) -> PhiValue raise BuilderError
fn Builder::build_ptr_compare(Self, IntPredicate, PointerValue, PointerValue, name~ : String = ..) -> IntValue raise BuilderError
fn Builder::build_ptr_diff(Self, &BasicType, PointerValue, PointerValue, name~ : String = ..) -> IntValue raise BuilderError
fn Builder::build_resume(Self, &BasicValue) -> InstructionValue raise BuilderError
fn[T : BasicValue] Builder::build_return(Self, T) -> InstructionValue raise BuilderError
fn Builder::build_return_void(Self) -> InstructionValue raise BuilderError
fn[T : IntMathValue] Builder::build_right_shift(Self, T, T, sign_extend~ : Bool = .., name~ : String = ..) -> T raise BuilderError
fn[BV : BasicValue, IMV : IntMathValue] Builder::build_select(Self, IMV, BV, BV, name~ : String = ..) -> BasicValueEnum raise BuilderError
fn[V : VectorBaseValue] Builder::build_shuffle_vector(Self, V, V, V, name~ : String = ..) -> V raise BuilderError
fn Builder::build_store(Self, PointerValue, &BasicValue) -> InstructionValue raise BuilderError
fn Builder::build_store_func(Self, PointerValue, FunctionValue) -> InstructionValue raise BuilderError
fn Builder::build_struct_gep(Self, &BasicType, PointerValue, UInt, name~ : String = ..) -> PointerValue raise BuilderError
fn Builder::build_switch(Self, IntValue, BasicBlock, Array[(IntValue, BasicBlock)]) -> InstructionValue raise BuilderError
fn Builder::build_unconditional_branch(Self, BasicBlock) -> InstructionValue raise BuilderError
fn Builder::build_unreachable(Self) -> InstructionValue raise BuilderError
fn[T : BasicType] Builder::build_va_arg(Self, PointerValue, T, name~ : String = ..) -> BasicValueEnum raise BuilderError
fn[T : IntMathValue] Builder::build_xor(Self, T, T, name~ : String = ..) -> T raise BuilderError
fn Builder::clear_insertion_position(Self) -> Unit
fn Builder::get_insert_block(Self) -> BasicBlock raise BuilderError
fn Builder::insert_instruction(Self, InstructionValue, String?) -> Unit
fn Builder::new(@unsafe.LLVMBuilderRef) -> Self
fn Builder::position_at(Self, BasicBlock, InstructionValue) -> Unit
fn Builder::position_at_end(Self, BasicBlock) -> Unit
fn Builder::position_before(Self, InstructionValue) -> Unit

pub suberror BuilderError {
  UnsetPosition
  AlignmentError(String)
  ExtractOutOfRange
  BitwidthError(String)
  PointeeTypeMismatch(String)
  ValueTypeMismatch(String)
  OrderingError(String)
  GEPPointee
  GEPIndex
}

pub struct CallSiteValue {
  value : ValueRef
}
fn CallSiteValue::add_attribute(Self, AttributeLoc, Attribute) -> Unit
fn CallSiteValue::count_arguments(Self) -> UInt
fn CallSiteValue::count_attributes(Self, AttributeLoc) -> UInt
fn CallSiteValue::get_call_convention(Self) -> UInt
fn CallSiteValue::get_called_fn_value(Self) -> FunctionValue
fn CallSiteValue::get_enum_attribute(Self, AttributeLoc, UInt) -> Attribute?
fn CallSiteValue::get_string_attribute(Self, AttributeLoc, String) -> Attribute?
fn CallSiteValue::get_tail_call_kind(Self) -> @unsafe.LLVMTailCallKind
fn CallSiteValue::is_tail_call(Self) -> Bool
fn CallSiteValue::new(@unsafe.LLVMValueRef) -> Self
fn CallSiteValue::remove_enum_attribute(Self, AttributeLoc, UInt) -> Unit
fn CallSiteValue::remove_string_attribute(Self, AttributeLoc, String) -> Unit
fn CallSiteValue::set_alignment_attribute(Self, AttributeLoc, UInt) -> Unit
fn CallSiteValue::set_call_convention(Self, UInt) -> Unit
fn CallSiteValue::set_tail_call(Self, Bool) -> Unit
fn CallSiteValue::set_tail_call_kind(Self, @unsafe.LLVMTailCallKind) -> Unit
fn CallSiteValue::try_as_basic_value(Self) -> Either[BasicValueEnum, InstructionValue]
impl Value for CallSiteValue
impl Show for CallSiteValue

pub struct CallableValue {
  either_value : Either[FunctionValue, PointerValue]
}
fn CallableValue::fromf(FunctionValue) -> Self
fn CallableValue::fromp(PointerValue) -> Self
fn CallableValue::inner(Self) -> @unsafe.LLVMValueRef

pub struct Comdat {
  comdat_ref : @unsafe.LLVMComdatRef
}
fn Comdat::as_comdat_ref(Self) -> @unsafe.LLVMComdatRef
fn Comdat::get_selection_kind(Self) -> ComdatSelectionKind
fn Comdat::new(@unsafe.LLVMComdatRef) -> Self
fn Comdat::set_selection_kind(Self, ComdatSelectionKind) -> Unit

pub(all) enum ComdatSelectionKind {
  Any
  ExactMatch
  Largest
  NoDuplicates
  SameSize
}
fn ComdatSelectionKind::from(@unsafe.LLVMComdatSelectionKind) -> Self
fn ComdatSelectionKind::into(Self) -> @unsafe.LLVMComdatSelectionKind

type Context
fn Context::append_basic_block(Self, FunctionValue, name~ : String = ..) -> BasicBlock
fn Context::bool_type(Self) -> IntType
fn Context::const_string(Self, String, Bool) -> ArrayValue
fn Context::const_struct(Self, Array[&BasicValue], packed~ : Bool = ..) -> StructValue
fn Context::create() -> Self
fn Context::create_builder(Self) -> Builder
fn Context::create_enum_attribute(Self, UInt, UInt64) -> Attribute
fn Context::create_module(Self, String) -> Module
fn Context::create_string_attribute(Self, String, String) -> Attribute
fn Context::create_type_attribute(Self, UInt, &Type) -> Attribute
fn Context::custom_width_int_type(Self, UInt) -> IntType
fn Context::drop(Self) -> Unit
fn Context::f128_type(Self) -> FloatType
fn Context::f16_type(Self) -> FloatType
fn Context::f32_type(Self) -> FloatType
fn Context::f64_type(Self) -> FloatType
fn Context::get_kind_id(Self, String) -> UInt
fn Context::get_struct_type(Self, String) -> StructType?
fn Context::i128_type(Self) -> IntType
fn Context::i16_type(Self) -> IntType
fn Context::i32_type(Self) -> IntType
fn Context::i64_type(Self) -> IntType
fn Context::i8_type(Self) -> IntType
fn Context::insert_basic_block_after(Self, BasicBlock, name~ : String = ..) -> BasicBlock
fn Context::metadata_node(Self, Array[&BasicValue]) -> MetadataValue
fn Context::metadata_string(Self, String) -> MetadataValue
fn Context::metadata_type(Self) -> MetadataType
fn Context::new(@unsafe.LLVMContextRef) -> Self
fn Context::opaque_struct_type(Self, String) -> StructType
fn Context::ppc_f128_type(Self) -> FloatType
fn Context::prepend_basic_block(Self, BasicBlock, String) -> BasicBlock
fn Context::ptr_type(Self, addr_space~ : AddressSpace = ..) -> PointerType
fn Context::struct_type(Self, Array[&BasicType], is_packed~ : Bool = ..) -> StructType
fn Context::void_type(Self) -> VoidType
fn Context::x86_f80_type(Self) -> FloatType
impl Eq for Context

pub(all) enum DLLStorageClass {
  Default
  DLLImport
  DLLExport
}
fn DLLStorageClass::from(@unsafe.LLVMDLLStorageClass) -> Self
fn DLLStorageClass::into(Self) -> @unsafe.LLVMDLLStorageClass
impl Eq for DLLStorageClass
impl Hash for DLLStorageClass
impl Show for DLLStorageClass

pub struct DebugInfoBuilder {
  builder : @unsafe.LLVMDIBuilderRef
}
fn DebugInfoBuilder::new(@unsafe.LLVMDIBuilderRef) -> Self

pub enum Either[L, R] {
  Left(L)
  Right(R)
}
fn[L, R] Either::expect_left(Self[L, R], String) -> L
fn[L, R] Either::expect_right(Self[L, R], String) -> R
fn[L, R] Either::is_left(Self[L, R]) -> Bool
fn[L, R] Either::is_right(Self[L, R]) -> Bool
fn[L, R] Either::left(Self[L, R]) -> L?
fn[L, R] Either::right(Self[L, R]) -> R?
fn[L, R] Either::unwrap_left(Self[L, R]) -> L
fn[L, R] Either::unwrap_right(Self[L, R]) -> R

pub type FastMathFlags UInt
fn FastMathFlags::from(@unsafe.LLVMFastMathFlags) -> Self
fn FastMathFlags::inner(Self) -> UInt
fn FastMathFlags::into(Self) -> @unsafe.LLVMFastMathFlags
impl Eq for FastMathFlags

pub(all) enum FlagBehavior {
  Error
  Warning
  Require
  Override
  Append
  AppendUnique
}
fn FlagBehavior::from(@unsafe.LLVMModuleFlagBehavior) -> Self
fn FlagBehavior::into(Self) -> @unsafe.LLVMModuleFlagBehavior

pub(all) enum FloatPredicate {
  OEQ
  OGE
  OGT
  OLE
  OLT
  ONE
  ORD
  PredicateFalse
  PredicateTrue
  UEQ
  UGE
  UGT
  ULE
  ULT
  UNE
  UNO
}
impl Eq for FloatPredicate
impl Hash for FloatPredicate
impl Show for FloatPredicate

pub struct FloatType {
  ty : TypeRef
}
fn FloatType::const_array(Self, Array[FloatValue]) -> ArrayValue
fn FloatType::const_float(Self, Double) -> FloatValue
fn FloatType::const_float_from_string(Self, String) -> FloatValue
fn FloatType::const_zero(Self) -> FloatValue
fn FloatType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn FloatType::get_alignment(Self) -> IntValue
fn FloatType::get_context(Self) -> Context
fn FloatType::get_poison(Self) -> FloatValue
fn FloatType::get_undef(Self) -> FloatValue
fn FloatType::is_sized(Self) -> Bool
fn FloatType::new(@unsafe.LLVMTypeRef) -> Self
impl BasicType for FloatType
impl Type for FloatType
impl Show for FloatType

pub struct FloatValue {
  value : ValueRef
}
fn FloatValue::as_instruction(Self) -> InstructionValue?
fn FloatValue::get_constant(Self) -> (Double, Bool)?
fn FloatValue::get_name(Self) -> String
fn FloatValue::get_type(Self) -> FloatType
fn FloatValue::is_const(Self) -> Bool
fn FloatValue::is_null(Self) -> Bool
fn FloatValue::is_undef(Self) -> Bool
fn FloatValue::new(@unsafe.LLVMValueRef) -> Self
fn FloatValue::replace_all_uses_with(Self, Self) -> Unit
fn FloatValue::set_name(Self, String) -> Unit
impl BasicValue for FloatValue
impl FloatMathValue for FloatValue
impl Value for FloatValue
impl Show for FloatValue

pub struct FunctionType {
  ty : TypeRef
}
fn FunctionType::count_param_types(Self) -> UInt
fn FunctionType::get_context(Self) -> Context
fn FunctionType::get_param_types(Self) -> Array[&BasicType]
fn FunctionType::get_return_type(Self) -> &BasicType?
fn FunctionType::is_sized(Self) -> Bool
fn FunctionType::is_var_arg(Self) -> Bool
fn FunctionType::new(@unsafe.LLVMTypeRef) -> Self
impl Type for FunctionType
impl Show for FunctionType

pub struct FunctionValue {
  value : ValueRef
}
fn FunctionValue::add_attribute(Self, AttributeLoc, Attribute) -> Unit
fn FunctionValue::as_global_value(Self) -> GlobalValue
fn FunctionValue::attributes(Self, AttributeLoc) -> Array[Attribute]
fn FunctionValue::count_attributes(Self, AttributeLoc) -> UInt
fn FunctionValue::count_basic_blocks(Self) -> UInt
fn FunctionValue::count_params(Self) -> UInt
fn FunctionValue::delete(Self) -> Unit
fn FunctionValue::drop(Self) -> Unit
fn FunctionValue::get_basic_blocks(Self) -> Array[BasicBlock]
fn FunctionValue::get_call_convention(Self) -> UInt
fn FunctionValue::get_enum_attribute(Self, AttributeLoc, UInt) -> Attribute?
fn FunctionValue::get_first_basic_block(Self) -> BasicBlock?
fn FunctionValue::get_first_param(Self) -> &BasicValue?
fn FunctionValue::get_gc(Self) -> String
fn FunctionValue::get_intrinsic_id(Self) -> UInt
fn FunctionValue::get_last_basic_block(Self) -> BasicBlock?
fn FunctionValue::get_last_param(Self) -> &BasicValue?
fn FunctionValue::get_linkage(Self) -> Linkage
fn FunctionValue::get_name(Self) -> String
fn FunctionValue::get_next_function(Self) -> Self?
fn FunctionValue::get_nth_param(Self, UInt) -> &BasicValue?
fn FunctionValue::get_params(Self) -> Array[&BasicValue]
fn FunctionValue::get_personality_function(Self) -> Self?
fn FunctionValue::get_previous_function(Self) -> Self?
fn FunctionValue::get_string_attribute(Self, AttributeLoc, String) -> Attribute?
fn FunctionValue::get_type(Self) -> FunctionType
fn FunctionValue::has_personality_function(Self) -> Bool
fn FunctionValue::is_null(Self) -> Bool
fn FunctionValue::is_undef(Self) -> Bool
fn FunctionValue::new(@unsafe.LLVMValueRef) -> Self?
fn FunctionValue::remove_enum_attribute(Self, AttributeLoc, UInt) -> Unit
fn FunctionValue::remove_string_attribute(Self, AttributeLoc, String) -> Unit
fn FunctionValue::replace_all_uses_with(Self, Self) -> Unit
fn FunctionValue::set_call_convention(Self, UInt) -> Unit
fn FunctionValue::set_gc(Self, String) -> Unit
fn FunctionValue::set_linkage(Self, Linkage) -> Unit
fn FunctionValue::set_param_alignment(Self, UInt, UInt) -> Unit
fn FunctionValue::set_personality_function(Self, Self) -> Unit
impl Value for FunctionValue
impl Eq for FunctionValue
impl Show for FunctionValue

pub struct GlobalValue {
  value : ValueRef
}
fn GlobalValue::as_pointer_value(Self) -> PointerValue
fn GlobalValue::delete(Self) -> Unit
fn GlobalValue::get_alignment(Self) -> UInt
fn GlobalValue::get_comdat(Self) -> Comdat?
fn GlobalValue::get_dll_storage_class(Self) -> DLLStorageClass
fn GlobalValue::get_initializer(Self) -> &BasicValue?
fn GlobalValue::get_linkage(Self) -> Linkage
fn GlobalValue::get_name(Self) -> String
fn GlobalValue::get_next_global(Self) -> Self?
fn GlobalValue::get_previous_global(Self) -> Self?
fn GlobalValue::get_section(Self) -> String
fn GlobalValue::get_thread_local_mode(Self) -> ThreadLocalMode
fn GlobalValue::get_value_type(Self) -> &Type
fn GlobalValue::has_unnamed_addr(Self) -> Bool
fn GlobalValue::is_constant(Self) -> Bool
fn GlobalValue::is_declaration(Self) -> Bool
fn GlobalValue::is_externally_initialized(Self) -> Bool
fn GlobalValue::is_thread_local(Self) -> Bool
fn GlobalValue::new(@unsafe.LLVMValueRef) -> Self
fn GlobalValue::set_alignment(Self, UInt) -> Unit
fn GlobalValue::set_constant(Self, Bool) -> Unit
fn GlobalValue::set_externally_initialized(Self, Bool) -> Unit
fn GlobalValue::set_initializer(Self, &BasicValue) -> Unit
fn GlobalValue::set_linkage(Self, Linkage) -> Unit
fn GlobalValue::set_metadata(Self, MetadataValue, UInt) -> Unit
fn GlobalValue::set_name(Self, String) -> Unit
fn GlobalValue::set_section(Self, String) -> Unit
fn GlobalValue::set_thread_local(Self, Bool) -> Unit
fn GlobalValue::set_thread_local_mode(Self, ThreadLocalMode) -> Unit
fn GlobalValue::set_unnamed_addr(Self, Bool) -> Unit
fn GlobalValue::set_unnamed_address(Self, UnnamedAddress) -> Unit
fn GlobalValue::set_visibility(Self, GlobalVisibility) -> Unit
impl Value for GlobalValue
impl Eq for GlobalValue
impl Show for GlobalValue

pub(all) enum GlobalVisibility {
  Default
  Hidden
  Protected
}
fn GlobalVisibility::from(@unsafe.LLVMVisibility) -> Self
fn GlobalVisibility::get_visibility(GlobalValue) -> Self
fn GlobalVisibility::into(Self) -> @unsafe.LLVMVisibility
impl Eq for GlobalVisibility
impl Hash for GlobalVisibility
impl Show for GlobalVisibility

pub(all) enum InlineAsmDialect {
  ATT
  Intel
}
fn InlineAsmDialect::from(@unsafe.LLVMInlineAsmDialect) -> Self
fn InlineAsmDialect::into(Self) -> @unsafe.LLVMInlineAsmDialect
impl Eq for InlineAsmDialect
impl Hash for InlineAsmDialect
impl Show for InlineAsmDialect

pub(all) enum InstructionOpcode {
  Add
  AddrSpaceCast
  Alloca
  And
  AShr
  AtomicCmpXchg
  AtomicRMW
  BitCast
  Br
  Call
  CallBr
  CatchPad
  CatchRet
  CatchSwitch
  CleanupPad
  CleanupRet
  ExtractElement
  ExtractValue
  FNeg
  FAdd
  FCmp
  FDiv
  Fence
  FMul
  FPExt
  FPToSI
  FPToUI
  FPTrunc
  Freeze
  FRem
  FSub
  GetElementPtr
  ICmp
  IndirectBr
  InsertElement
  InsertValue
  IntToPtr
  Invoke
  LandingPad
  Load
  LShr
  Mul
  Or
  Phi
  PtrToInt
  Resume
  Return
  SDiv
  Select
  SExt
  Shl
  ShuffleVector
  SIToFP
  SRem
  Store
  Sub
  Switch
  Trunc
  UDiv
  UIToFP
  Unreachable
  URem
  UserOp1
  UserOp2
  VAArg
  Xor
  ZExt
}
fn InstructionOpcode::from(@unsafe.LLVMOpcode) -> Self
fn InstructionOpcode::into(Self) -> @unsafe.LLVMOpcode
impl Eq for InstructionOpcode
impl Hash for InstructionOpcode
impl Show for InstructionOpcode

pub struct InstructionValue {
  value : ValueRef
}
fn InstructionValue::can_use_fast_math_flags(Self) -> Bool
fn InstructionValue::erase_from_basic_block(Self) -> Unit
fn InstructionValue::explicit_clone(Self) -> Self
fn InstructionValue::get_alignment(Self) -> Result[UInt, String]
fn InstructionValue::get_allocated_type(Self) -> Result[&BasicType, String]
fn InstructionValue::get_atomic_ordering(Self) -> Result[AtomicOrdering, String]
fn InstructionValue::get_disjoint_flag(Self) -> Bool?
fn InstructionValue::get_fast_math_flags(Self) -> FastMathFlags?
fn InstructionValue::get_fcmp_predicate(Self) -> FloatPredicate?
fn InstructionValue::get_first_use(Self) -> BasicValueUse?
fn InstructionValue::get_gep_source_element_type(Self) -> Result[&BasicType, String]
fn InstructionValue::get_icmp_predicate(Self) -> IntPredicate?
fn InstructionValue::get_instruction_with_name(Self, String) -> Self?
fn InstructionValue::get_metadata(Self, UInt) -> MetadataValue?
fn InstructionValue::get_name(Self) -> String?
fn InstructionValue::get_next_instruction(Self) -> Self?
fn InstructionValue::get_non_negative_flag(Self) -> Bool?
fn InstructionValue::get_num_operands(Self) -> UInt
fn InstructionValue::get_opcode(Self) -> InstructionOpcode
fn InstructionValue::get_operand(Self, UInt) -> Either[BasicValueEnum, BasicBlock]?
fn InstructionValue::get_operand_use(Self, UInt) -> BasicValueUse?
fn InstructionValue::get_parent(Self) -> BasicBlock?
fn InstructionValue::get_previous_instruction(Self) -> Self?
fn InstructionValue::get_tail_call_kind(Self) -> @unsafe.LLVMTailCallKind?
fn InstructionValue::get_type(Self) -> &Type
fn InstructionValue::get_volatile(Self) -> Result[Bool, String]
fn InstructionValue::has_metadata(Self) -> Bool
fn InstructionValue::is_a_alloca_inst(Self) -> Bool
fn InstructionValue::is_a_atomicrmw_inst(Self) -> Bool
fn InstructionValue::is_a_cmpxchg_inst(Self) -> Bool
fn InstructionValue::is_a_getelementptr_inst(Self) -> Bool
fn InstructionValue::is_a_load_inst(Self) -> Bool
fn InstructionValue::is_a_store_inst(Self) -> Bool
fn InstructionValue::is_conditional(Self) -> Bool
fn InstructionValue::is_tail_call(Self) -> Bool
fn InstructionValue::is_terminator(Self) -> Bool
fn InstructionValue::new(@unsafe.LLVMValueRef) -> Self
fn InstructionValue::remove_from_basic_block(Self) -> Unit
fn InstructionValue::replace_all_uses_with(Self, Self) -> Unit
fn InstructionValue::set_alignment(Self, UInt) -> Result[Unit, String]
fn InstructionValue::set_atomic_ordering(Self, AtomicOrdering) -> Result[Unit, String]
fn InstructionValue::set_disjoint_flag(Self, Bool) -> Unit
fn InstructionValue::set_fast_math_flags(Self, FastMathFlags) -> Unit
fn InstructionValue::set_metadata(Self, MetadataValue, UInt) -> Unit raise MoonllvmError
fn InstructionValue::set_name(Self, String) -> Unit
fn InstructionValue::set_non_negative_flag(Self, Bool) -> Unit
fn InstructionValue::set_operand(Self, UInt, &BasicValue) -> Bool
fn InstructionValue::set_volatile(Self, Bool) -> Result[Unit, String]
impl Value for InstructionValue
impl Show for InstructionValue

pub(all) enum IntPredicate {
  EQ
  NE
  UGT
  UGE
  ULT
  ULE
  SGT
  SGE
  SLT
  SLE
}
fn IntPredicate::from(@unsafe.LLVMIntPredicate) -> Self
fn IntPredicate::into(Self) -> @unsafe.LLVMIntPredicate
impl Eq for IntPredicate
impl Hash for IntPredicate
impl Show for IntPredicate

pub struct IntType {
  ty : TypeRef
}
fn IntType::const_all_ones(Self) -> IntValue
fn IntType::const_array(Self, Array[IntValue]) -> ArrayValue
fn IntType::const_int(Self, UInt64, sign_extend~ : Bool = ..) -> IntValue
fn IntType::const_int_arbitrary_precision(Self, Array[UInt64]) -> IntValue
fn IntType::const_zero(Self) -> IntValue
fn IntType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn IntType::get_alignment(Self) -> IntValue
fn IntType::get_bit_width(Self) -> UInt
fn IntType::get_context(Self) -> Context
fn IntType::get_poison(Self) -> IntValue
fn IntType::get_undef(Self) -> IntValue
fn IntType::is_sized(Self) -> Bool
fn IntType::new(@unsafe.LLVMTypeRef) -> Self
impl BasicType for IntType
impl Type for IntType
impl Show for IntType

pub struct IntValue {
  value : ValueRef
}
fn IntValue::as_instruction(Self) -> InstructionValue?
fn IntValue::const_add(Self, Self) -> Self
fn IntValue::const_bit_cast(Self, IntType) -> Self
fn IntValue::const_mul(Self, Self) -> Self
fn IntValue::const_neg(Self) -> Self
fn IntValue::const_not(Self) -> Self
fn IntValue::const_nsw_add(Self, Self) -> Self
fn IntValue::const_nsw_mul(Self, Self) -> Self
fn IntValue::const_nsw_neg(Self) -> Self
fn IntValue::const_nsw_sub(Self, Self) -> Self
fn IntValue::const_nuw_add(Self, Self) -> Self
fn IntValue::const_nuw_mul(Self, Self) -> Self
fn IntValue::const_nuw_sub(Self, Self) -> Self
fn IntValue::const_sub(Self, Self) -> Self
fn IntValue::const_to_pointer(Self, PointerType) -> PointerValue
fn IntValue::const_truncate(Self, IntType) -> Self
fn IntValue::const_truncate_or_bit_cast(Self, IntType) -> Self
fn IntValue::const_xor(Self, Self) -> Self
fn IntValue::get_name(Self) -> String
fn IntValue::get_sign_extended_constant(Self) -> Int64?
fn IntValue::get_type(Self) -> IntType
fn IntValue::get_zero_extended_constant(Self) -> UInt64?
fn IntValue::is_const(Self) -> Bool
fn IntValue::is_constant_int(Self) -> Bool
fn IntValue::is_null(Self) -> Bool
fn IntValue::is_undef(Self) -> Bool
fn IntValue::new(@unsafe.LLVMValueRef) -> Self
fn IntValue::replace_all_uses_with(Self, Self) -> Unit
fn IntValue::set_name(Self, String) -> Unit
impl BasicValue for IntValue
impl IntMathValue for IntValue
impl Value for IntValue
impl Show for IntValue

pub struct Intrinsic {
  id : UInt
}
fn Intrinsic::find(String) -> Self?
fn Intrinsic::get_declaration(Self, Module, Array[&BasicType]) -> FunctionValue?
fn Intrinsic::is_overloaded(Self) -> Bool
fn Intrinsic::new(UInt) -> Self

pub(all) enum Linkage {
  Appending
  AvailableExternally
  Common
  DLLExport
  DLLImport
  External
  ExternalWeak
  Ghost
  Internal
  LinkerPrivate
  LinkerPrivateWeak
  LinkOnceAny
  LinkOnceODRAutoHide
  LinkOnceODR
  Private
  WeakAny
  WeakODR
}
fn Linkage::from(@unsafe.LLVMLinkage) -> Self
fn Linkage::into(Self) -> @unsafe.LLVMLinkage
impl Show for Linkage

pub struct MemoryBuffer {
  memory_buffer : @unsafe.LLVMMemoryBufferRef
}
fn MemoryBuffer::as_mem_buf(Self) -> @unsafe.LLVMMemoryBufferRef
fn MemoryBuffer::dispose(Self) -> Unit
fn MemoryBuffer::drop(Self) -> Unit
fn MemoryBuffer::get_size(Self) -> Int
fn MemoryBuffer::new(@unsafe.LLVMMemoryBufferRef) -> Self

pub struct MetadataType {
  ty : TypeRef
}
fn MetadataType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn MetadataType::get_context(Self) -> Context
fn MetadataType::new(@unsafe.LLVMTypeRef) -> Self
impl Type for MetadataType
impl Show for MetadataType

pub struct MetadataValue {
  value : ValueRef
}
fn MetadataValue::as_metadata_ref(Self) -> @unsafe.LLVMMetadataRef
fn MetadataValue::get_name(Self) -> String
fn MetadataValue::get_node_size(Self) -> UInt
fn MetadataValue::get_string_value(Self) -> String?
fn MetadataValue::is_node(Self) -> Bool
fn MetadataValue::is_string(Self) -> Bool
fn MetadataValue::new(@unsafe.LLVMValueRef) -> Self
fn MetadataValue::replace_all_uses_with(Self, Self) -> Unit
impl Value for MetadataValue
impl Show for MetadataValue

pub struct Module {
  module_ref : @unsafe.LLVMModuleRef
}
fn Module::add_function(Self, String, FunctionType, linkage~ : Linkage? = ..) -> FunctionValue
fn[T : BasicType] Module::add_global(Self, T, AddressSpace?, String) -> GlobalValue
fn Module::add_global_metadata(Self, String, MetadataValue) -> Result[Unit, String]
fn Module::as_mod_ref(Self) -> @unsafe.LLVMModuleRef
fn Module::drop(Self) -> Unit
fn Module::dump(Self) -> Unit
fn Module::get_context(Self) -> Context
fn Module::get_first_function(Self) -> FunctionValue?
fn Module::get_first_global(Self) -> GlobalValue?
fn Module::get_function(Self, String) -> FunctionValue?
fn Module::get_functions(Self) -> Array[FunctionValue]
fn Module::get_global(Self, String) -> GlobalValue?
fn Module::get_global_metadata(Self, String) -> Array[MetadataValue]
fn Module::get_global_metadata_size(Self, String) -> UInt
fn Module::get_last_function(Self) -> FunctionValue?
fn Module::get_last_global(Self) -> GlobalValue?
fn Module::get_name(Self) -> String
fn Module::get_source_filename(Self) -> String
fn Module::get_struct_type(Self, String) -> StructType?
fn Module::new(@unsafe.LLVMModuleRef) -> Self
fn Module::print_to_stderr(Self) -> Unit
fn Module::print_to_string(Self) -> String
fn Module::set_inline_assembly(Self, String) -> Unit
fn Module::set_name(Self, String) -> Unit
fn Module::set_source_filename(Self, String) -> Unit
impl Show for Module

pub suberror MoonllvmError {
  IntoTypeError(String)
  IntoValueError(String)
  BasicBlockHasNoParent
  SetBodyForNonOpaqueStruct
  MetadataNotNode
}
impl Show for MoonllvmError

pub struct OperandBundle {
  bundle : @unsafe.LLVMOperandBundleRef
}
fn OperandBundle::as_bundle_ref(Self) -> @unsafe.LLVMOperandBundleRef
fn OperandBundle::create(String, Array[&Value]) -> Self
fn OperandBundle::drop(Self) -> Unit
fn OperandBundle::get_args(Self) -> Array[&BasicValue]
fn OperandBundle::get_tag(Self) -> String
fn OperandBundle::new(@unsafe.LLVMOperandBundleRef) -> Self

pub(all) enum OptimizationLevel {
  None
  Less
  Default
  Aggressive
}
fn OptimizationLevel::from_int(Int) -> Self
impl Eq for OptimizationLevel
impl Hash for OptimizationLevel
impl Show for OptimizationLevel

pub struct PassBuilderOptions {
  options_ref : @unsafe.LLVMPassBuilderOptionsRef
}
fn PassBuilderOptions::as_options_ref(Self) -> @unsafe.LLVMPassBuilderOptionsRef
fn PassBuilderOptions::new() -> Self
fn PassBuilderOptions::set_call_graph_profile(Self, Bool) -> Unit
fn PassBuilderOptions::set_debug_logging(Self, Bool) -> Unit
fn PassBuilderOptions::set_forget_all_scev_in_loop_unroll(Self, Bool) -> Unit
fn PassBuilderOptions::set_licm_mssa_no_acc_for_promotion_cap(Self, UInt) -> Unit
fn PassBuilderOptions::set_licm_mssa_opt_cap(Self, UInt) -> Unit
fn PassBuilderOptions::set_loop_interleaving(Self, Bool) -> Unit
fn PassBuilderOptions::set_loop_slp_vectorization(Self, Bool) -> Unit
fn PassBuilderOptions::set_loop_unrolling(Self, Bool) -> Unit
fn PassBuilderOptions::set_loop_vectorization(Self, Bool) -> Unit
fn PassBuilderOptions::set_merge_functions(Self, Bool) -> Unit
fn PassBuilderOptions::set_verify_each(Self, Bool) -> Unit

pub struct PhiValue {
  value : ValueRef
}
fn PhiValue::add_incoming(Self, &BasicValue, BasicBlock) -> Unit
fn PhiValue::add_incomings(Self, Array[(&BasicValue, BasicBlock)]) -> Unit
fn PhiValue::as_basic_value(Self) -> BasicValueEnum
fn PhiValue::as_instruction(Self) -> InstructionValue?
fn PhiValue::count_incoming(Self) -> UInt
fn PhiValue::dump(Self) -> Unit
fn PhiValue::get_incoming(Self, UInt) -> (BasicValueEnum, BasicBlock)?
fn PhiValue::get_incoming_unchecked(Self, UInt) -> (BasicValueEnum, BasicBlock)
fn PhiValue::get_name(Self) -> String
fn PhiValue::get_type(Self) -> BasicTypeEnum
fn PhiValue::is_null(Self) -> Bool
fn PhiValue::is_undef(Self) -> Bool
fn PhiValue::new(@unsafe.LLVMValueRef) -> Self
fn PhiValue::replace_all_uses_with(Self, Self) -> Unit
fn PhiValue::set_name(Self, String) -> Unit
impl Value for PhiValue
impl Show for PhiValue

pub struct PointerType {
  ty : TypeRef
}
fn PointerType::const_array(Self, Array[PointerValue]) -> ArrayValue
fn PointerType::const_null(Self) -> PointerValue
fn PointerType::const_zero(Self) -> PointerValue
fn PointerType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn PointerType::get_address_space(Self) -> AddressSpace
fn PointerType::get_alignment(Self) -> IntValue
fn PointerType::get_context(Self) -> Context
fn PointerType::get_element_type(Self) -> &Type
fn PointerType::get_poison(Self) -> PointerValue
fn PointerType::get_undef(Self) -> PointerValue
fn PointerType::is_opaque(Self) -> Bool
fn PointerType::is_sized(Self) -> Bool
fn PointerType::new(@unsafe.LLVMTypeRef) -> Self
impl BasicType for PointerType
impl Type for PointerType
impl Show for PointerType

pub struct PointerValue {
  value : ValueRef
}
fn PointerValue::as_instruction(Self) -> InstructionValue?
fn PointerValue::const_address_space_cast(Self, PointerType) -> Self
fn PointerValue::const_cast(Self, PointerType) -> Self
fn PointerValue::const_gep(Self, &BasicType, Array[IntValue]) -> Self
fn PointerValue::const_in_bounds_gep(Self, &BasicType, Array[IntValue]) -> Self
fn PointerValue::const_to_int(Self, IntType) -> IntValue
fn PointerValue::get_name(Self) -> String
fn PointerValue::get_type(Self) -> PointerType
fn PointerValue::is_const(Self) -> Bool
fn PointerValue::is_null(Self) -> Bool
fn PointerValue::is_undef(Self) -> Bool
fn PointerValue::new(@unsafe.LLVMValueRef) -> Self
fn PointerValue::replace_all_uses_with(Self, Self) -> Unit
fn PointerValue::set_name(Self, String) -> Unit
impl BasicValue for PointerValue
impl PointerMathValue for PointerValue
impl Value for PointerValue
impl Show for PointerValue

type PositionState
impl Eq for PositionState
impl Show for PositionState

pub struct ScalableVectorType {
  ty : TypeRef
}
fn ScalableVectorType::const_array(Self, Array[ScalableVectorValue]) -> ArrayValue
fn ScalableVectorType::const_zero(Self) -> ScalableVectorValue
fn ScalableVectorType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn ScalableVectorType::get_alignment(Self) -> IntValue
fn ScalableVectorType::get_context(Self) -> Context
fn ScalableVectorType::get_element_type(Self) -> BasicTypeEnum
fn ScalableVectorType::get_poison(Self) -> ScalableVectorValue
fn ScalableVectorType::get_size(Self) -> UInt
fn ScalableVectorType::get_undef(Self) -> ScalableVectorValue
fn ScalableVectorType::is_sized(Self) -> Bool
fn ScalableVectorType::new(@unsafe.LLVMTypeRef) -> Self
impl BasicType for ScalableVectorType
impl Type for ScalableVectorType
impl Show for ScalableVectorType

pub struct ScalableVectorValue {
  value : ValueRef
}
fn ScalableVectorValue::as_instruction(Self) -> InstructionValue?
fn ScalableVectorValue::const_extract_element(Self, IntValue) -> BasicValueEnum
fn ScalableVectorValue::const_insert_element(Self, &BasicValue, IntValue) -> BasicValueEnum
fn ScalableVectorValue::const_shuffle_vector(Self, Self, Self) -> Self
fn ScalableVectorValue::get_name(Self) -> String
fn ScalableVectorValue::get_type(Self) -> ScalableVectorType
fn ScalableVectorValue::is_const(Self) -> Bool
fn ScalableVectorValue::is_null(Self) -> Bool
fn ScalableVectorValue::is_undef(Self) -> Bool
fn ScalableVectorValue::new(@unsafe.LLVMValueRef) -> Self
fn ScalableVectorValue::replace_all_uses_with(Self, Self) -> Unit
fn ScalableVectorValue::set_name(Self, String) -> Unit
impl AggregateValue for ScalableVectorValue
impl BasicValue for ScalableVectorValue
impl FloatMathValue for ScalableVectorValue
impl IntMathValue for ScalableVectorValue
impl PointerMathValue for ScalableVectorValue
impl Value for ScalableVectorValue
impl VectorBaseValue for ScalableVectorValue
impl Show for ScalableVectorValue

pub struct StructType {
  ty : TypeRef
}
fn StructType::const_array(Self, Array[StructValue]) -> ArrayValue
fn StructType::const_named_struct(Self, Array[&BasicValue]) -> StructValue
fn StructType::const_zero(Self) -> StructValue
fn StructType::count_fields(Self) -> UInt
fn StructType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn StructType::get_alignment(Self) -> IntValue
fn StructType::get_context(Self) -> Context
fn StructType::get_field_type_at_index(Self, UInt) -> &BasicType?
fn StructType::get_field_types(Self) -> Array[&BasicType]
fn StructType::get_name(Self) -> String
fn StructType::get_poison(Self) -> StructValue
fn StructType::get_undef(Self) -> StructValue
fn StructType::is_opaque(Self) -> Bool
fn StructType::is_packed(Self) -> Bool
fn StructType::is_sized(Self) -> Bool
fn StructType::new(@unsafe.LLVMTypeRef) -> Self
fn StructType::set_body(Self, Array[&BasicType], is_packed~ : Bool = ..) -> Unit raise MoonllvmError
impl BasicType for StructType
impl Type for StructType
impl Show for StructType

pub struct StructValue {
  value : ValueRef
}
fn StructValue::as_instruction(Self) -> InstructionValue?
fn StructValue::count_fields(Self) -> UInt
fn StructValue::get_field_at_index(Self, UInt) -> BasicValueEnum?
fn StructValue::get_name(Self) -> String
fn StructValue::get_type(Self) -> StructType
fn StructValue::is_const(Self) -> Bool
fn StructValue::is_null(Self) -> Bool
fn StructValue::is_undef(Self) -> Bool
fn StructValue::new(@unsafe.LLVMValueRef) -> Self
fn StructValue::replace_all_uses_with(Self, Self) -> Unit
fn StructValue::set_field_at_index(Self, UInt, &BasicValue) -> Bool
fn StructValue::set_name(Self, String) -> Unit
impl AggregateValue for StructValue
impl BasicValue for StructValue
impl Value for StructValue
impl Show for StructValue

pub(all) enum ThreadLocalMode {
  NotThreadLocal
  GeneralDynamic
  LocalDynamic
  InitialExec
  LocalExec
}
fn ThreadLocalMode::from(@unsafe.LLVMThreadLocalMode) -> Self
fn ThreadLocalMode::into(Self) -> @unsafe.LLVMThreadLocalMode
impl Eq for ThreadLocalMode
impl Hash for ThreadLocalMode
impl Show for ThreadLocalMode

pub enum TypeEnum {
  VoidType(VoidType)
  IntType(IntType)
  FloatType(FloatType)
  PointerType(PointerType)
  StructType(StructType)
  FunctionType(FunctionType)
  ArrayType(ArrayType)
  VectorType(VectorType)
  ScalableVectorType(ScalableVectorType)
  MetadataType(MetadataType)
}
fn TypeEnum::as_type_class(Self) -> &Type
fn TypeEnum::init(@unsafe.LLVMTypeRef) -> Self

type TypeRef
fn TypeRef::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType

pub(all) enum UnnamedAddress {
  None
  Local
  Global
}
fn UnnamedAddress::from(@unsafe.LLVMUnnamedAddr) -> Self
fn UnnamedAddress::into(Self) -> @unsafe.LLVMUnnamedAddr
impl Eq for UnnamedAddress
impl Show for UnnamedAddress

pub enum ValueEnum {
  IntValue(IntValue)
  FloatValue(FloatValue)
  PointerValue(PointerValue)
  StructValue(StructValue)
  FunctionValue(FunctionValue)
  ArrayValue(ArrayValue)
  VectorValue(VectorValue)
  PhiValue(PhiValue)
  ScalableVectorValue(ScalableVectorValue)
  MetadataValue(MetadataValue)
  CallSiteValue(CallSiteValue)
  GlobalValue(GlobalValue)
  InstructionValue(InstructionValue)
}
fn ValueEnum::as_value_class(Self) -> &Value
fn ValueEnum::init(@unsafe.LLVMValueRef) -> Self

type ValueRef
impl Eq for ValueRef
impl Show for ValueRef

pub struct VectorType {
  ty : TypeRef
}
fn VectorType::const_array(Self, Array[VectorValue]) -> ArrayValue
fn VectorType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn VectorType::get_alignment(Self) -> IntValue
fn VectorType::get_context(Self) -> Context
fn VectorType::get_element_type(Self) -> &BasicType
fn VectorType::get_poison(Self) -> VectorValue
fn VectorType::get_size(Self) -> UInt
fn VectorType::get_undef(Self) -> VectorValue
fn VectorType::is_sized(Self) -> Bool
fn VectorType::new(@unsafe.LLVMTypeRef) -> Self
impl BasicType for VectorType
impl Type for VectorType
impl Show for VectorType

pub struct VectorValue {
  value : ValueRef
}
fn VectorValue::as_instruction(Self) -> InstructionValue?
fn VectorValue::const_shuffle_vector(Self, Self, Self) -> Self
fn VectorValue::get_name(Self) -> String
fn VectorValue::get_type(Self) -> VectorType
fn VectorValue::is_const(Self) -> Bool
fn VectorValue::is_constant_data_vector(Self) -> Bool
fn VectorValue::is_constant_vector(Self) -> Bool
fn VectorValue::is_null(Self) -> Bool
fn VectorValue::is_undef(Self) -> Bool
fn VectorValue::new(@unsafe.LLVMValueRef) -> Self
fn VectorValue::replace_all_uses_with(Self, Self) -> Unit
fn VectorValue::set_name(Self, String) -> Unit
impl AggregateValue for VectorValue
impl BasicValue for VectorValue
impl FloatMathValue for VectorValue
impl IntMathValue for VectorValue
impl PointerMathValue for VectorValue
impl Value for VectorValue
impl VectorBaseValue for VectorValue
impl Show for VectorValue

pub struct VoidType {
  ty : TypeRef
}
fn VoidType::fn_type(Self, Array[&BasicType], is_var_arg~ : Bool = ..) -> FunctionType
fn VoidType::get_alignment(Self) -> IntValue
fn VoidType::get_context(Self) -> Context
fn VoidType::is_sized(Self) -> Bool
fn VoidType::new(@unsafe.LLVMTypeRef) -> Self
impl Type for VoidType
impl Show for VoidType

impl Eq for &BasicType
impl Show for &BasicType

impl Eq for &BasicValue
impl Show for &BasicValue

impl Eq for &Type
impl Show for &Type

impl Eq for &Value
impl Show for &Value

// Type aliases

// Traits
pub trait AggregateValue : Value {
  as_aggregate_value_enum(Self) -> AggregateValueEnum
}

pub trait BasicType : Type {
  as_basic_type_enum(Self) -> BasicTypeEnum
}

pub trait BasicValue : Value {
  as_basic_value_enum(Self) -> BasicValueEnum
}

pub trait FloatMathValue : BasicValue {
  new(@unsafe.LLVMValueRef) -> Self
}

pub trait IntMathValue : BasicValue {
  new(@unsafe.LLVMValueRef) -> Self
}

pub trait PointerMathValue : BasicValue {
  new(@unsafe.LLVMValueRef) -> Self
}

pub trait Type {
  base(Self) -> TypeRef
  as_type_enum(Self) -> TypeEnum
  try_as_basic_type_enum(Self) -> BasicTypeEnum?
  inner(Self) -> @unsafe.LLVMTypeRef
  dump(Self) -> Unit
  is_sized(Self) -> Bool
  type_name(Self) -> String
  get_context(Self) -> Context
  ptr_type(Self, AddressSpace) -> PointerType
  vec_type(Self, UInt) -> VectorType
  scalable_vec_type(Self, UInt) -> ScalableVectorType
  array_type(Self, UInt) -> ArrayType
  fn_type(Self, Array[&BasicType]) -> FunctionType
  size_of(Self) -> IntValue?
  get_undef(Self) -> &Value
  get_poison(Self) -> &Value
  get_alignment(Self) -> IntValue
  into_void_type(Self) -> VoidType raise MoonllvmError
  into_int_type(Self) -> IntType raise MoonllvmError
  into_float_type(Self) -> FloatType raise MoonllvmError
  into_pointer_type(Self) -> PointerType raise MoonllvmError
  into_struct_type(Self) -> StructType raise MoonllvmError
  into_function_type(Self) -> FunctionType raise MoonllvmError
  into_array_type(Self) -> ArrayType raise MoonllvmError
  into_vector_type(Self) -> VectorType raise MoonllvmError
  into_scalable_vector_type(Self) -> ScalableVectorType raise MoonllvmError
  into_metadata_type(Self) -> MetadataType raise MoonllvmError
  try_as_basic_type(Self) -> &BasicType?
  into_basic_type(Self) -> &BasicType raise MoonllvmError
}

pub trait Value {
  base(Self) -> ValueRef
  as_value_enum(Self) -> ValueEnum
  inner(Self) -> @unsafe.LLVMValueRef
  dump(Self) -> Unit
  get_type(Self) -> &Type
  is_instruction(Self) -> Bool
  as_instruction(Self) -> InstructionValue?
  is_const(Self) -> Bool
  get_name(Self) -> String
  set_name(Self, String) -> Unit
  is_undef(Self) -> Bool
  into_int_value(Self) -> IntValue raise MoonllvmError
  into_float_value(Self) -> FloatValue raise MoonllvmError
  into_pointer_value(Self) -> PointerValue raise MoonllvmError
  into_struct_value(Self) -> StructValue raise MoonllvmError
  into_function_value(Self) -> FunctionValue raise MoonllvmError
  into_array_value(Self) -> ArrayValue raise MoonllvmError
  into_vector_value(Self) -> VectorValue raise MoonllvmError
  into_phi_value(Self) -> PhiValue raise MoonllvmError
  into_scalable_vector_value(Self) -> ScalableVectorValue raise MoonllvmError
  into_metadata_value(Self) -> MetadataValue raise MoonllvmError
  into_call_site_value(Self) -> CallSiteValue raise MoonllvmError
  into_global_value(Self) -> GlobalValue raise MoonllvmError
  into_instruction_value(Self) -> InstructionValue raise MoonllvmError
  try_as_basic_value_enum(Self) -> BasicValueEnum?
  try_as_basic_value(Self) -> &BasicValue?
  into_basic_value(Self) -> &BasicValue raise MoonllvmError
}

pub trait VectorBaseValue : BasicValue {
  new(@unsafe.LLVMValueRef) -> Self
}

